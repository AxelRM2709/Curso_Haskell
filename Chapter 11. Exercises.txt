Chapter 11. Exercises

1. Using the `gametree` function, verify that there are 549,946 nodes in the complete game tree for a 3x3 tic-tac-toe game starting from the empty grid, and that the maximum depth of this tree is 9.

countnodes:: Tree a -> Int
countnodes (Node _ g) = 1 + sum (map countnodes g)
-- g :: [Tree a], so we use map to apply countnodes


depthtree:: Tree a -> Int
depthtree (Node _ []) = 0
depthtree (Node _ g) = 1 + maximum (map depthtree g)

Using these functions we can calculate it

2. Our tic-tac-toe program always chooses the first move from the list of best moves. Modify the final program to choose a random move from the list of best moves, using the `randomRIO :: (Int, Int) -> IO Int` function from `System.Random` to generate a random integer in the given range.

I couldn't use System.Random, but i think this functions works

randmove :: Grid -> Player -> IO Grid
randmove g p = do
    i <- randomRIO (0, size^2 - 1) 
    if valid g i 
        then return (head (move g i p))
        else randmove g p  

3. Alternatively, modify the final program to choose a move that attempts to take the quickest route to
 a win, by calculating the depths of resulting game trees and selecting a move that results in a tree
 with the smallest depth.

bestmoves :: Grid -> Player -> [Grid]
bestmoves g p = [g' | Node (g',p') _ <- ts, p' == best] -- Saves all wining moves 
    where
        tree = prune depth (gametree g p)
        Node (_,best) ts = minimax tree

depths :: Grid -> Player -> [Int]
depths xs p = [depthtree (gametree g p) | g<-bestmoves xs p] --bestmoves xs p calculates the bestmoves,
--gametree g p, calculates the gametree of the each bestmove and depthtree its depth

findmin :: [Int] -> Int --function that returns the position of the minimum element
findmin xs = head [ b |(a,b) <- zip xs [0..(length xs - 1)], a==minimum xs ]

blitz :: Grid -> Player -> Grid
blitz g p = bestmoves g p !! findmin (depths g p)

--(play $! (bestmove g p)) (next p)
(play $! blitz g p) (next p) -- And use this in the function play'

4. Modify the final program to:

a) let the user decide if they wish to play first or second;

b) allow the length of a winning line to also be changed;

c) generate the game tree once, rather than for each move;

d) reduce the size of game tree using alpha-beta pruning.

In progress...